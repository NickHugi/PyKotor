"""Comprehensive integration and validation tests for KotorDiff INI generation.

This test suite combines execution, validation, and structure tests for the
KotorDiff INI generation system. It includes:
- Full KotorDiff execution tests with granular validation
- 1:1 reference file comparison tests
- Header structure and format validation
- Section and key-value validation

Only `test_01_step1_generate_patch` exercises production code. Steps 2 through 4
serve as validator confirmations that reuse artifacts produced in step 1 to
assert expectations about end-to-end behavior. They remain in this module to
offer a consolidated round-trip workflow but they do not introduce new code
paths beyond what step 1 already executed.
"""

from __future__ import annotations

import contextlib
import cProfile
import io
import os
import pathlib
import pstats
import sys
import traceback
import unittest

from threading import Event
from typing import TYPE_CHECKING

# Set up import paths
THIS_SCRIPT_PATH = pathlib.Path(__file__).resolve()
PYKOTOR_PATH = THIS_SCRIPT_PATH.parents[2] / "Libraries" / "PyKotor" / "src"
UTILITY_PATH = THIS_SCRIPT_PATH.parents[2] / "Libraries" / "Utility" / "src"
KOTORDIFF_PATH = THIS_SCRIPT_PATH.parents[2] / "Tools" / "KotorDiff" / "src"
HOLOPATCHER_PATH = THIS_SCRIPT_PATH.parents[2] / "Tools" / "HoloPatcher" / "src"

if PYKOTOR_PATH.as_posix() not in sys.path:
    sys.path.insert(0, PYKOTOR_PATH.as_posix())
if UTILITY_PATH.as_posix() not in sys.path:
    sys.path.insert(0, UTILITY_PATH.as_posix())
if KOTORDIFF_PATH.as_posix() not in sys.path:
    sys.path.insert(0, KOTORDIFF_PATH.as_posix())
if HOLOPATCHER_PATH.as_posix() not in sys.path:
    sys.path.insert(0, HOLOPATCHER_PATH.as_posix())

from holopatcher.core import uninstall_mod, install_mod, load_mod, validate_game_directory, validate_install_paths, format_install_time  # pyright: ignore[reportMissingImports]
from kotordiff.app import KotorDiffConfig, run_application  # pyright: ignore[reportMissingImports]
from pykotor.extract.installation import Installation
from pykotor.tslpatcher.logger import PatchLogger
from pathlib import Path


@contextlib.contextmanager
def capture_output_to_file(log_file_path: Path):
    """Context manager to capture stdout and stderr to a file.

    Args:
        log_file_path: Path to the log file where output will be saved.
    """
    log_file_path.parent.mkdir(parents=True, exist_ok=True)

    # Create StringIO buffers for stdout and stderr
    stdout_buffer = io.StringIO()
    stderr_buffer = io.StringIO()

    # Save the original streams
    original_stdout = sys.stdout
    original_stderr = sys.stderr

    try:
        # Replace with our buffers
        sys.stdout = stdout_buffer
        sys.stderr = stderr_buffer

        # Yield control
        yield

    finally:
        # Restore original streams
        sys.stdout = original_stdout
        sys.stderr = original_stderr

        # Get captured content
        stdout_content = stdout_buffer.getvalue()
        stderr_content = stderr_buffer.getvalue()

        # Write to file
        with log_file_path.open("w", encoding="utf-8") as log_file:
            if stdout_content:
                log_file.write("=== STDOUT ===\n")
                log_file.write(stdout_content)
                if not stdout_content.endswith("\n"):
                    log_file.write("\n")
            if stderr_content:
                log_file.write("=== STDERR ===\n")
                log_file.write(stderr_content)
                if not stderr_content.endswith("\n"):
                    log_file.write("\n")


def get_test_paths() -> tuple[str, str]:
    """Get test paths from environment variables or use defaults.

    Returns:
        Tuple of (path1_vanilla, path2_modded)
    """
    path1 = os.environ.get("K1_VANILLA_PATH", r"C:\Program Files (x86)\Steam\steamapps\common\swkotor - Vanilla")
    path2 = os.environ.get("K1_SLEHEYRON_PATH", r"C:\Program Files (x86)\Steam\steamapps\common\swkotor")
    return path1, path2


def get_expected_header_lines(today: str) -> list[str]:
    """Get the expected header lines with updated branding.

    Args:
        today: Date string in format MM/DD/YYYY

    Returns:
        List of expected header lines (52 lines total including blank at end)
    """
    return [
        "; ============================================================================",
        f";  TSLPatcher Modifications File — Generated by HoloPatcher ({today})",
        "; ============================================================================",
        ";",
        ";  Crafted by: th3w1zard1 (Boden Crouch) with love for the KOTOR community",
        ";",
        ";  This file is part of the PyKotor ecosystem — an exhaustive modding for",
        ";  Knights of the Old Republic development, built to be cross-platform,",
        ";  reproducible, and future-proof.",
        ";",
        ";  Core Ecosystem Components:",
        ";    • PyKotor: Python library for reading/writing KOTOR formats",
        ";    • HoloPatcher: Cross-platform TSLPatcher alternative",
        ";    • HolocronToolset: Complete modding suite for KotOR I & II",
        ";    • KotorDiff: Advanced diff engine for patch generation",
        ";        https://github.com/th3w1zard1/PyKotor",
        ";    • KOTORModSync: Multi-mod installer with conflict resolution",
        ";        https://github.com/th3w1zard1/KOTORModSync",
        ";    • HoloLSP: The first ever Language Server Protocol for KotOR",
        ";        https://github.com/th3w1zard1/HoloLSP",
        ";    • HoloPatcher.NET: .NET implementation of HoloPatcher",
        ";        https://github.com/th3w1zard1/HoloPatcher.NET",
        ";",
        ";  https://www.bolabaden.org  - Self-Hosted Infrastructure and Initiatives",
        ";",
        ";  Developer Initiatives — bolabaden Organization:",
        ";    • bolabaden-site: Main website + frontend",
        ";        https://github.com/bolabaden/bolabaden-site",
        ";    • bolabaden-infra: Kubernetes backbone for bolabaden.org",
        ";        https://github.com/bolabaden/bolabaden-infra",
        ";    • ai-researchwizard: AI-powered research assistant",
        ";        https://github.com/bolabaden/ai-researchwizard",
        ";",
        ";",
        "; ----------------------------------------------------------------------------",
        ";  FORMATTING NOTES:",
        ";    • This file is TSLPatcher-compliant and machine-generated.",
        ";    • You may add blank lines between sections (for readability).",
        ";    • You may add comment lines starting with semicolon.",
        ";    • Do NOT add blank lines or comments inside a section (between keys).",
        "; ============================================================================",
        "",
    ]


def get_expected_ini_content_from_reference(today: str) -> str:
    """Load reference INI and replace header with updated branding.

    Args:
        today: Date string in format MM/DD/YYYY

    Returns:
        Complete expected INI content
    """
    # Read the reference INI file
    reference_path = Path(__file__).resolve().parent / "reference_changes.ini"
    if not reference_path.exists():
        raise FileNotFoundError(f"Reference INI not found at {reference_path}")

    with reference_path.open("r", encoding="utf-8") as f:
        lines = f.readlines()

    # Find where the header ends (first line starting with [)
    body_start_index = 0
    for i, line in enumerate(lines):
        if line.strip().startswith("["):
            body_start_index = i
            break

    # Get the new header
    new_header_lines = get_expected_header_lines(today)
    new_header = "\n".join(new_header_lines)

    # Get body content (everything after the header)
    body = "".join(lines[body_start_index:])

    return new_header + body


class TestKotorDiffFullExecution(unittest.TestCase):
    """Integration test that executes KotorDiff and validates ALL output.

    Only `test_01_step1_generate_patch` runs the production logic under test.
    The remaining step methods do not call new code; instead, they operate as
    post-generation validators that confirm the artifacts produced in step 1
    behave as expected when consumed by HoloPatcher tooling. They live alongside
    the main test for convenience so that a developer can execute a single test
    suite and receive comprehensive feedback.

    Tests are designed to run independently or as a full suite:
    - test_01_step1_generate_patch: Generates changes.ini from vanilla vs modded
      **This is the only method that executes the code under test.**
    - test_02_step2_install_patch: Installs changes.ini to test installation
      (validator only, reuses step 1 output)
    - test_03_step3_verify_installation: Diffs installed installation to verify
      (validator only, reuses prior outputs)
    - test_04_step4_uninstall_patch: Uninstalls mod from test installation
      (cleanup utility)

    Each test can be run independently - it will check for prerequisites and
    skip or fail appropriately. Run all tests together for a full roundtrip.
    """

    # Class-level state shared between tests
    tslpatchdata_path: Path = Path("tslpatchdata")
    generated_ini_path: Path | None = None
    test_install_path: Path | None = None
    mod_info_for_uninstall = None
    path1_vanilla: str | None = None
    path2_modded: str | None = None
    step3_completed: bool = False

    @classmethod
    def setUpClass(cls):
        """Initialize shared test state."""
        cls.tslpatchdata_path = Path("tslpatchdata")
        cls.path1_vanilla, cls.path2_modded = get_test_paths()
        cls.generated_ini_path = cls.tslpatchdata_path / "changes.ini"
        cls.test_install_path = None
        cls.mod_info_for_uninstall = None
        cls.step3_completed = False

    def _save_profiler_results(self, profiler: cProfile.Profile, profiler_output_file: Path, profiler_summary_file: Path, step_name: str):
        """Save profiler results to files."""
        try:
            profiler.dump_stats(str(profiler_output_file))
            print(f"[TEST] Profile data saved to: {profiler_output_file}")

            with profiler_summary_file.open("w", encoding="utf-8") as summary_f:
                stats = pstats.Stats(profiler, stream=summary_f)
                stats.strip_dirs()

                summary_f.write("=" * 80 + "\n")
                summary_f.write(f"PROFILE SUMMARY - {step_name} - Sorted by Cumulative Time\n")
                summary_f.write("=" * 80 + "\n\n")
                stats.sort_stats("cumulative")
                stats.print_stats(50)

                summary_f.write("\n" + "=" * 80 + "\n")
                summary_f.write(f"PROFILE SUMMARY - {step_name} - Sorted by Total Time\n")
                summary_f.write("=" * 80 + "\n\n")
                stats.sort_stats("tottime")
                stats.print_stats(50)

                summary_f.write("\n" + "=" * 80 + "\n")
                summary_f.write(f"PROFILE SUMMARY - {step_name} - Callers (Top 30)\n")
                summary_f.write("=" * 80 + "\n\n")
                stats.sort_stats("cumulative")
                stats.print_callers(30)

            print(f"[TEST] Profile summary saved to: {profiler_summary_file}")
            print(f"[TEST] To view profile:")
            print(f"[TEST]   CLI (built-in): python -m pstats {profiler_output_file}")
            print(f"[TEST]   Visual (SnakeViz): uv pip install snakeviz && snakeviz {profiler_output_file}")
        except Exception as e:
            print(f"[TEST] Warning: Failed to save profile data: {e}")

    def test_01_step1_generate_patch(self):
        """Step 1: Run KotorDiff to generate changes.ini from vanilla vs modded installation.

        This test generates the patch file by comparing two installations.
        Can be run independently to regenerate the patch from scratch.
        """
        profiler = cProfile.Profile()
        profiler_output_file = self.tslpatchdata_path / "test_step1_generate_patch_profile.prof"
        profiler_summary_file = self.tslpatchdata_path / "test_step1_generate_patch_profile_summary.txt"

        try:
            profiler.enable()
            print(f"[TEST] Step 1: Generate patch - Profiling enabled")

            # Verify paths exist
            if not Path(self.path1_vanilla).exists():
                self.skipTest(f"Vanilla installation not found at {self.path1_vanilla}")
            if not Path(self.path2_modded).exists():
                self.skipTest(f"Modded installation not found at {self.path2_modded}")

            # Ensure paths are not None
            if self.path1_vanilla is None or self.path2_modded is None:
                self.fail("Test paths not initialized")

            print(f"\n[TEST] Step 1: Running KotorDiff:")
            print(f"  Path1 (vanilla): {self.path1_vanilla}")
            print(f"  Path2 (modded):  {self.path2_modded}")

            # Create paths list with Installation objects for the test paths
            paths: list[Path | Installation] = [
                Installation(self.path1_vanilla),
                Installation(self.path2_modded),
            ]

            # Create configuration
            config = KotorDiffConfig(
                paths=paths,
                tslpatchdata_path=self.tslpatchdata_path,
                ini_filename="changes.ini",
                compare_hashes=True,
                logging_enabled=True,
            )

            # Run the app
            print(f"[TEST] Executing KotorDiff...")
            result = run_application(config)
            print(f"[TEST] KotorDiff completed with exit code: {result}")

            # Verify changes.ini was generated
            if self.generated_ini_path is None or not self.generated_ini_path.exists() or not self.generated_ini_path.is_file():
                self.fail(f"Cannot proceed: changes.ini was not generated at {self.generated_ini_path}")

            print(f"[TEST] ✓ Step 1 completed: changes.ini generated successfully at {self.generated_ini_path}")

        except KeyboardInterrupt:
            print(f"\n[TEST] KeyboardInterrupt: Step 1 was cancelled by user")
            raise
        except BaseException as e:
            print(f"[TEST] Step 1 failed: {e.__class__.__name__}: {e}")
            traceback.print_exc()
            raise
        finally:
            profiler.disable()
            self._save_profiler_results(profiler, profiler_output_file, profiler_summary_file, "Step 1: Generate Patch")

    def test_02_step2_install_patch(self):
        """Step 2 validator: install the generated changes.ini using HoloPatcher.

        This method is a *validator* that consumes the output from
        `test_01_step1_generate_patch`. It deliberately exercises no new product
        code paths beyond those already touched in step 1; instead, it exists to
        assert that the generated INI installs cleanly. Prerequisites:
        `changes.ini` must exist (from step 1). Can be run independently if
        `changes.ini` already exists.
        """
        profiler = cProfile.Profile()
        profiler_output_file = self.tslpatchdata_path / "test_step2_install_patch_profile.prof"
        profiler_summary_file = self.tslpatchdata_path / "test_step2_install_patch_profile_summary.txt"

        try:
            profiler.enable()
            print(f"[TEST] Step 2: Install patch - Profiling enabled")

            # Check prerequisite: changes.ini must exist
            if not self.generated_ini_path or not self.generated_ini_path.exists():
                self.skipTest(f"Cannot proceed: changes.ini not found at {self.generated_ini_path}. Run test_01_step1_generate_patch first.")

            print(f"[TEST] ✓ Found changes.ini at {self.generated_ini_path}")

            # Load mod from tslpatchdata directory
            mod_info = load_mod(str(self.tslpatchdata_path))
            print(f"[TEST] Loaded mod with {len(mod_info.namespaces)} namespace(s)")

            # Select first namespace
            selected_namespace = mod_info.namespaces[0].name
            print(f"[TEST] Selected namespace: {selected_namespace}")

            # Ensure path1_vanilla is not None
            if self.path1_vanilla is None:
                self.fail("Vanilla path not initialized")

            # Validate game path
            self.test_install_path = Path(self.path1_vanilla).parent / "swkotor - Vanilla - Copy"
            game_path = validate_game_directory(self.test_install_path.as_posix())
            print(f"[TEST] Validated game path: {game_path}")

            # Validate install paths
            assert validate_install_paths(mod_info.mod_path, game_path), f"Invalid mod or game paths: mod={mod_info.mod_path}, game={game_path}"

            # Install the mod
            patcher_logger = PatchLogger()
            should_cancel = Event()
            print(f"[TEST] Installing mod...")
            install_result = install_mod(
                mod_info.mod_path,
                game_path,
                mod_info.namespaces,
                selected_namespace,
                patcher_logger,
                should_cancel,
            )

            print(f"[TEST] Install completed:")
            print(f"  Errors: {install_result.num_errors}")
            print(f"  Warnings: {install_result.num_warnings}")
            print(f"  Patches: {install_result.num_patches}")
            print(f"  Time: {format_install_time(install_result.install_time)}")

            assert install_result.num_errors == 0, f"Installation had {install_result.num_errors} errors"
            assert install_result.num_patches > 0, f"Installation should have applied patches, got {install_result.num_patches}"

            # Store mod_info for potential uninstall
            self.mod_info_for_uninstall = mod_info
            print(f"[TEST] ✓ Step 2 completed: Installation successful")

        except KeyboardInterrupt:
            print(f"\n[TEST] KeyboardInterrupt: Step 2 was cancelled by user")
            raise
        except BaseException as e:
            print(f"[TEST] Step 2 failed: {e.__class__.__name__}: {e}")
            traceback.print_exc()
            raise
        finally:
            profiler.disable()
            self._save_profiler_results(profiler, profiler_output_file, profiler_summary_file, "Step 2: Install Patch")

    def test_03_step3_verify_installation(self):
        """Step 3 validator: diff the installed test installation against vanilla.

        This method serves as a *validator* that confirms the installation
        performed in step 2 matches expectations by re-running KotorDiff. It is
        not an additional unit under test; it merely compares artifacts produced
        earlier in the workflow. Prerequisites: installation must be complete
        (from step 2). Can be run independently if installation already exists.
        """
        profiler = cProfile.Profile()
        profiler_output_file = self.tslpatchdata_path / "test_step3_verify_installation_profile.prof"
        profiler_summary_file = self.tslpatchdata_path / "test_step3_verify_installation_profile_summary.txt"

        try:
            profiler.enable()
            print(f"[TEST] Step 3: Verify installation - Profiling enabled")

            # Check prerequisites
            if self.path1_vanilla is None:
                self.fail("Vanilla path not initialized")

            if not self.test_install_path:
                self.test_install_path = Path(self.path1_vanilla).parent / "swkotor - Vanilla - Copy"

            if not self.test_install_path.exists():
                self.skipTest(f"Cannot proceed: Test installation not found at {self.test_install_path}. Run test_02_step2_install_patch first.")

            print(f"[TEST] ✓ Found test installation at {self.test_install_path}")

            # Create a temporary tslpatchdata directory for the verification diff
            verify_tslpatchdata_path = Path("tslpatchdata_verify")
            verify_tslpatchdata_path.mkdir(exist_ok=True)

            # Ensure path1_vanilla is not None
            if self.path1_vanilla is None:
                self.fail("Vanilla path not initialized")

            # Run KotorDiff for verification
            # Note: We're diffing test_install_path (which has mod installed) to path1_vanilla
            # If installation worked correctly, this diff should show the same changes as the original diff
            print(f"[TEST] Running KotorDiff to diff installed test installation to path1 (vanilla)...")
            verify_result = run_application(
                config=KotorDiffConfig(
                    paths=[Installation(self.test_install_path), Installation(self.path1_vanilla)],
                    tslpatchdata_path=verify_tslpatchdata_path,
                    ini_filename="verify_changes.ini",
                    compare_hashes=True,
                    logging_enabled=True,
                )
            )
            assert verify_result == 0, f"Verification KotorDiff failed with exit code: {verify_result}"
            print(f"[TEST] Verification KotorDiff completed with exit code: {verify_result}")

            # Mark step 3 as completed successfully
            self.step3_completed = True
            print(f"[TEST] ✓ Step 3 completed: Verification successful")

        except KeyboardInterrupt:
            print(f"\n[TEST] KeyboardInterrupt: Step 3 was cancelled by user")
            raise
        except BaseException as e:
            print(f"[TEST] Step 3 failed: {e.__class__.__name__}: {e}")
            traceback.print_exc()
            # Don't fail the test here, but step3_completed remains False
            # This means uninstall won't run in cleanup
        finally:
            profiler.disable()
            self._save_profiler_results(profiler, profiler_output_file, profiler_summary_file, "Step 3: Verify Installation")

    def test_04_step4_uninstall_patch(self):
        """Step 4 cleanup validator: uninstall the mod from the test installation.

        This method provides cleanup and final confirmation. It does not test new
        product code; it reuses state created earlier to ensure the environment
        can be returned to baseline. Prerequisites: installation must be complete
        (from step 2). Can be run independently for cleanup.
        """
        profiler = cProfile.Profile()
        profiler_output_file = self.tslpatchdata_path / "test_step4_uninstall_patch_profile.prof"
        profiler_summary_file = self.tslpatchdata_path / "test_step4_uninstall_patch_profile_summary.txt"

        try:
            profiler.enable()
            print(f"[TEST] Step 4: Uninstall patch - Profiling enabled")

            # Check prerequisites
            if self.path1_vanilla is None:
                self.fail("Vanilla path not initialized")

            if not self.test_install_path:
                self.test_install_path = Path(self.path1_vanilla).parent / "swkotor - Vanilla - Copy"

            if not self.test_install_path.exists():
                self.skipTest(f"Cannot proceed: Test installation not found at {self.test_install_path}. Nothing to uninstall.")

            if not self.mod_info_for_uninstall:
                # Try to load mod info if not already loaded
                try:
                    self.mod_info_for_uninstall = load_mod(str(self.tslpatchdata_path))
                    print(f"[TEST] Loaded mod info for uninstall")
                except Exception as e:
                    self.skipTest(f"Cannot proceed: Could not load mod info for uninstall: {e}. Run test_02_step2_install_patch first.")

            print(f"[TEST] Uninstalling mod from {self.test_install_path}...")
            patcher_logger = PatchLogger()
            fully_ran = uninstall_mod(self.mod_info_for_uninstall.mod_path, self.test_install_path.as_posix(), patcher_logger)

            if fully_ran:
                print(f"[TEST] ✓ Step 4 completed: Uninstall successful")
            else:
                print(f"[TEST] ⚠ Step 4 completed: Uninstall completed with warnings")

        except KeyboardInterrupt:
            print(f"\n[TEST] KeyboardInterrupt: Step 4 was cancelled by user")
            raise
        except BaseException as e:
            print(f"[TEST] Step 4 failed (non-fatal): {e.__class__.__name__}: {e}")
            traceback.print_exc()
            # Don't fail the test - uninstall is cleanup
        finally:
            profiler.disable()
            self._save_profiler_results(profiler, profiler_output_file, profiler_summary_file, "Step 4: Uninstall Patch")

def report_test_errors(errors: list[str], test_case: unittest.TestCase):
    """Report all errors at the end."""
    if errors:
        error_summary = f"\n{'=' * 80}\nFOUND {len(errors)} VALIDATION ERROR(S):\n{'=' * 80}\n"
        for i, error in enumerate(errors, 1):
            error_summary += f"\n{i}. {error}\n"
        error_summary += f"{'=' * 80}\n"
        test_case.fail(error_summary)


if __name__ == "__main__":
    unittest.main()
