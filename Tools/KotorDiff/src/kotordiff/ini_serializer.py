"""Expert-level TSLPatcher INI serialization that generates exact, compliant changes.ini files.

This module provides precise TSLPatcher INI format generation based on analysis of:
- TSLPatcher test cases and expected output formats
- TSLPatcher reader implementation for parsing logic
- Exact section ordering and naming conventions
- Proper handling of all modifier types and their parameters
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

from pykotor.common.geometry import Vector3, Vector4
from pykotor.common.language import LocalizedString
from pykotor.common.misc import ResRef
from pykotor.resource.formats.gff.gff_data import GFFStruct
from pykotor.resource.formats.ssf.ssf_data import SSFSound
from pykotor.tslpatcher.mods.gff import AddFieldGFF, AddStructToListGFF, FieldValueConstant, ModifyFieldGFF
from pykotor.tslpatcher.mods.tlk import ModificationsTLK
from pykotor.tslpatcher.mods.twoda import AddColumn2DA, AddRow2DA, ChangeRow2DA, TargetType

if TYPE_CHECKING:
    from kotordiff.__main__ import ModificationsByType
    from pykotor.tslpatcher.mods.gff import ModificationsGFF
    from pykotor.tslpatcher.mods.ssf import ModificationsSSF
    from pykotor.tslpatcher.mods.twoda import Modifications2DA


class TSLPatcherINISerializer:
    """Serializes PatcherModifications objects to exact TSLPatcher INI format."""

    def serialize(
        self,
        modifications_by_type: ModificationsByType,
        *,
        include_header: bool = True,
        include_settings: bool = False,
    ) -> str:
        """Generate complete INI content from modifications.

        Args:
            modifications_by_type: ModificationsByType from __main__.py
            include_header: Whether to include comment header (default: True)
            include_settings: Whether to include [Settings] section (default: False)
        """
        lines: list[str] = []

        # Add header comment
        if include_header:
            lines.extend(self._generate_header())

        # Add [Settings] section if requested
        if include_settings:
            lines.extend(self._generate_settings())

        # Order matters per TSLPatcher convention:
        # [TLKList], [InstallList], [2DAList], [GFFList], [CompileList], [SSFList]
        lines.extend(self._serialize_tlk_list(modifications_by_type.tlk))
        lines.extend(self._serialize_install_list(modifications_by_type.install))
        lines.extend(self._serialize_2da_list(modifications_by_type.twoda))
        lines.extend(self._serialize_gff_list(modifications_by_type.gff))
        lines.extend(self._serialize_ssf_list(modifications_by_type.ssf))

        return "\n".join(lines)

    def _generate_header(self) -> list[str]:
        """Generate INI file header comment."""
        from datetime import datetime, timezone  # noqa: PLC0415

        today = datetime.now(tz=timezone.utc).strftime("%m/%d/%Y")
        return [
            "; =====================================================[Generated by KotorDiff]====",
            f"; TSLPATCHER - GENERATED MODIFICATIONS File ({today})",
            "; ===================================================================",
            "; This File is automatically generated and as such has no formatting",
            "; to speak of. You can insert blank lines between sections (but NOT",
            "; between keys within a section!) and add comment lines starting",
            "; with semicolon to make it more readable without breaking anything.",
            "; -------------------------------------------------------------------",
            "",
        ]

    def _generate_settings(self) -> list[str]:
        """Generate default [Settings] section."""
        return [
            "[Settings]",
            "LogLevel=3",
            "",
        ]

    def _serialize_2da_list(
        self,
        modifications: list[Modifications2DA],
    ) -> list[str]:
        """Serialize [2DAList] section."""
        if not modifications:
            return []

        lines: list[str] = []
        lines.append("[2DAList]")

        for idx, mod_2da in enumerate(modifications):
            lines.append(f"Table{idx}={mod_2da.sourcefile}")
        lines.append("")

        # Generate each 2DA file's sections
        for mod_2da in modifications:
            lines.extend(self._serialize_2da_file(mod_2da))

        return lines

    def _serialize_2da_file(
        self,
        mod_2da: Modifications2DA,
    ) -> list[str]:
        """Serialize a single 2DA file's modifications."""
        lines: list[str] = []
        lines.append(f"[{mod_2da.sourcefile}]")

        # List all modifiers
        modifier_idx = 0
        for modifier in mod_2da.modifiers:
            if isinstance(modifier, ChangeRow2DA):
                section_name = modifier.identifier or f"{mod_2da.sourcefile}_changerow_{modifier_idx}"
                lines.append(f"ChangeRow{modifier_idx}={section_name}")
                modifier_idx += 1
            elif isinstance(modifier, AddRow2DA):
                section_name = modifier.identifier or f"{mod_2da.sourcefile}_addrow_{modifier_idx}"
                lines.append(f"AddRow{modifier_idx}={section_name}")
                modifier_idx += 1
            elif isinstance(modifier, AddColumn2DA):
                section_name = modifier.identifier or f"{mod_2da.sourcefile}_addcol_{modifier_idx}"
                lines.append(f"AddColumn{modifier_idx}={section_name}")
                modifier_idx += 1
        lines.append("")

        # Generate detailed sections for each modifier
        for modifier in mod_2da.modifiers:
            if isinstance(modifier, (ChangeRow2DA, AddRow2DA, AddColumn2DA)):
                lines.extend(self._serialize_2da_modifier(modifier))

        return lines

    def _serialize_2da_modifier(  # noqa: C901, PLR0912
        self,
        modifier: ChangeRow2DA | AddRow2DA | AddColumn2DA,
    ) -> list[str]:
        """Serialize a single 2DA modifier section with exact TSLPatcher format."""
        lines: list[str] = []
        section_name = modifier.identifier

        if isinstance(modifier, ChangeRow2DA):
            lines.append(f"[{section_name}]")

            # Target specification (exactly as TSLPatcher expects)
            if modifier.target.target_type == TargetType.ROW_INDEX:
                lines.append(f"RowIndex={modifier.target.value}")
            elif modifier.target.target_type == TargetType.ROW_LABEL:
                lines.append(f"RowLabel={modifier.target.value}")
            elif modifier.target.target_type == TargetType.LABEL_COLUMN:
                lines.append(f"LabelIndex={modifier.target.value}")

            # Cell modifications (preserve exact column names and values)
            for col, row_value in modifier.cells.items():
                cell_val = self._serialize_row_value(row_value)
                lines.append(f"{col}={cell_val}")

            # Store 2DA memory assignments (if any)
            if hasattr(modifier, "store_2da") and modifier.store_2da:
                for token_id, row_value in modifier.store_2da.items():
                    store_val = self._serialize_row_value(row_value)
                    lines.append(f"2DAMEMORY{token_id}={store_val}")

            # Store TLK memory assignments (if any)
            if hasattr(modifier, "store_tlk") and modifier.store_tlk:
                for token_id, row_value in modifier.store_tlk.items():
                    store_val = self._serialize_row_value(row_value)
                    lines.append(f"StrRef{token_id}={store_val}")

            lines.append("")

        elif isinstance(modifier, AddRow2DA):
            lines.append(f"[{section_name}]")

            # Exclusive column (prevents duplicate values)
            if modifier.exclusive_column:
                lines.append(f"ExclusiveColumn={modifier.exclusive_column}")

            # Row label (if specified)
            if modifier.row_label:
                lines.append(f"RowLabel={modifier.row_label}")

            # Cell values
            for col, row_value in modifier.cells.items():
                cell_val = self._serialize_row_value(row_value)
                lines.append(f"{col}={cell_val}")

            # Store 2DA memory assignments (if any)
            if hasattr(modifier, "store_2da") and modifier.store_2da:
                for token_id, row_value in modifier.store_2da.items():
                    store_val = self._serialize_row_value(row_value)
                    lines.append(f"2DAMEMORY{token_id}={store_val}")

            # Store TLK memory assignments (if any)
            if hasattr(modifier, "store_tlk") and modifier.store_tlk:
                for token_id, row_value in modifier.store_tlk.items():
                    store_val = self._serialize_row_value(row_value)
                    lines.append(f"StrRef{token_id}={store_val}")

            lines.append("")

        elif isinstance(modifier, AddColumn2DA):
            lines.append(f"[{section_name}]")
            lines.append(f"ColumnLabel={modifier.header}")
            lines.append(f"DefaultValue={modifier.default if modifier.default else '****'}")

            # Index-based inserts (I0=value, I1=value, etc.)
            for row_idx, row_value in modifier.index_insert.items():
                idx_val = self._serialize_row_value(row_value)
                lines.append(f"I{row_idx}={idx_val}")

            # Label-based inserts (Llabel=value)
            for row_label, row_value in modifier.label_insert.items():
                label_val = self._serialize_row_value(row_value)
                lines.append(f"L{row_label}={label_val}")

            # Store 2DA memory assignments (if any)
            if hasattr(modifier, "store_2da") and modifier.store_2da:
                for token_id, store_val in modifier.store_2da.items():
                    lines.append(f"2DAMEMORY{token_id}={store_val}")

            lines.append("")

        return lines

    def _serialize_row_value(self, row_value: Any) -> str:
        """Serialize a RowValue to its TSLPatcher string representation."""
        # Handle different RowValue types exactly as TSLPatcher expects
        if hasattr(row_value, "string"):  # RowValueConstant
            return str(row_value.string)
        if hasattr(row_value, "token_id"):  # RowValue2DAMemory or RowValueTLKMemory
            if "2DAMemory" in type(row_value).__name__:
                return f"2DAMEMORY{row_value.token_id}"
            if "TLKMemory" in type(row_value).__name__:
                return f"StrRef{row_value.token_id}"
        elif hasattr(row_value, "column"):  # RowValueHigh
            return f"High{row_value.column}" if row_value.column else "High"
        elif hasattr(row_value, "value"):  # Generic value method
            return str(row_value.value(None, None, None))  # type: ignore[arg-type]
        return str(row_value)

    def _serialize_gff_list(
        self,
        modifications: list[ModificationsGFF],
    ) -> list[str]:
        """Serialize [GFFList] section with exact TSLPatcher format."""
        if not modifications:
            return []

        lines: list[str] = []
        lines.append("[GFFList]")

        for idx, mod_gff in enumerate(modifications):
            # Use Replace# or File# based on replace_file flag
            prefix = "Replace" if getattr(mod_gff, "replace_file", False) else "File"
            lines.append(f"{prefix}{idx}={mod_gff.sourcefile}")
        lines.append("")

        # Generate each GFF file's sections
        for mod_gff in modifications:
            lines.extend(self._serialize_gff_file(mod_gff))

        return lines

    def _serialize_gff_file(
        self,
        mod_gff: ModificationsGFF,
    ) -> list[str]:
        """Serialize a single GFF file's modifications with exact TSLPatcher format."""
        lines: list[str] = []
        lines.append(f"[{mod_gff.sourcefile}]")

        # Add TSLPatcher exclamation-point variables if present
        if hasattr(mod_gff, "replace_file"):
            lines.append(f"!ReplaceFile={'1' if mod_gff.replace_file else '0'}")
        if hasattr(mod_gff, "destination") and mod_gff.destination != "Override":
            lines.append(f"!Destination={mod_gff.destination}")
        if hasattr(mod_gff, "saveas") and mod_gff.saveas != mod_gff.sourcefile:
            lines.append(f"!Filename={mod_gff.saveas}")

        # Collect AddField indices first
        addfield_modifiers = []

        # Process modifiers in order
        for gff_modifier in mod_gff.modifiers:
            if isinstance(gff_modifier, ModifyFieldGFF):
                # Direct field modification: Path=Value (use backslashes per TSLPatcher)
                path_str = str(gff_modifier.path).replace("/", "\\")
                value_str = self._serialize_field_value(gff_modifier.value)
                lines.append(f"{path_str}={value_str}")

            elif isinstance(gff_modifier, (AddFieldGFF, AddStructToListGFF)):
                addfield_modifiers.append(gff_modifier)

        # Add AddField# references
        for idx, gff_modifier in enumerate(addfield_modifiers):
            section_name = gff_modifier.identifier or f"addfield_{idx}"
            lines.append(f"AddField{idx}={section_name}")

        lines.append("")

        # Generate AddField subsections after the main file section
        for idx, gff_modifier in enumerate(addfield_modifiers):
            section_name = gff_modifier.identifier or f"addfield_{idx}"
            lines.extend(self._serialize_addfield_section(gff_modifier, section_name))

        return lines

    def _serialize_addfield_section(  # noqa: C901, PLR0912, PLR0915
        self,
        gff_modifier: AddFieldGFF | AddStructToListGFF,
        section_name: str,
    ) -> list[str]:
        """Serialize an AddField or AddStructToListGFF subsection with exact TSLPatcher format."""
        from pykotor.resource.formats.gff.gff_data import GFFFieldType  # noqa: PLC0415

        lines: list[str] = []
        lines.append(f"[{section_name}]")

        # Determine if this is AddStructToListGFF or AddFieldGFF
        is_add_struct_to_list = isinstance(gff_modifier, AddStructToListGFF)

        # FieldType - AddStructToListGFF is always Struct type
        if is_add_struct_to_list:
            field_type_name = "Struct"
        elif isinstance(gff_modifier, AddFieldGFF):
            field_type_name = self._get_gff_field_type_name(gff_modifier.field_type)
        else:
            field_type_name = "Struct"  # Default fallback
        lines.append(f"FieldType={field_type_name}")

        # Label - AddStructToListGFF doesn't have label, use empty string
        label = getattr(gff_modifier, "label", "")
        lines.append(f"Label={label}")

        # Path (use backslashes)
        path_str = str(gff_modifier.path).replace("/", "\\")
        lines.append(f"Path={path_str}")

        # Add field value based on type
        if is_add_struct_to_list:
            # AddStructToListGFF always has TypeId
            if isinstance(gff_modifier.value, FieldValueConstant) and isinstance(gff_modifier.value.stored, GFFStruct):
                lines.append(f"TypeId={gff_modifier.value.stored.struct_id}")
        elif hasattr(gff_modifier, "field_type"):
            if gff_modifier.field_type == GFFFieldType.Struct:
                # For Struct, we need TypeId instead of Value
                if isinstance(gff_modifier.value, FieldValueConstant) and isinstance(gff_modifier.value.stored, GFFStruct):
                    lines.append(f"TypeId={gff_modifier.value.stored.struct_id}")
            elif gff_modifier.field_type in (GFFFieldType.List,):
                # Lists don't need a Value
                pass
            elif gff_modifier.field_type == GFFFieldType.LocalizedString:
                # LocalizedString uses StrRef and lang# keys
                self._serialize_localized_string_value(gff_modifier.value, lines)
            else:
                # Regular value
                value_str = self._serialize_field_value(gff_modifier.value)
                if value_str:  # Only add Value= if there's an actual value
                    lines.append(f"Value={value_str}")

        # Process nested modifiers (if any)
        if hasattr(gff_modifier, "modifiers") and gff_modifier.modifiers:
            for nested_idx, nested_mod in enumerate(gff_modifier.modifiers):
                if isinstance(nested_mod, (AddFieldGFF, AddStructToListGFF)):
                    nested_section = nested_mod.identifier or f"{section_name}_nested_{nested_idx}"
                    lines.append(f"AddField{nested_idx}={nested_section}")

        lines.append("")

        # Recursively generate nested AddField/AddStructToListGFF sections
        if hasattr(gff_modifier, "modifiers") and gff_modifier.modifiers:
            for nested_idx, nested_mod in enumerate(gff_modifier.modifiers):
                if isinstance(nested_mod, (AddFieldGFF, AddStructToListGFF)):
                    nested_section = nested_mod.identifier or f"{section_name}_nested_{nested_idx}"
                    lines.extend(self._serialize_addfield_section(nested_mod, nested_section))

        return lines

    def _serialize_localized_string_value(
        self,
        field_value: Any,
        lines: list[str],
    ) -> None:  # noqa: C901
        """Serialize LocalizedString field value to TSLPatcher format."""
        from pykotor.common.language import LocalizedString  # noqa: PLC0415

        # Extract the actual LocalizedString from FieldValue wrapper
        loc_string = None
        if hasattr(field_value, "stored"):
            loc_string = field_value.stored
        elif isinstance(field_value, LocalizedString):
            loc_string = field_value

        if loc_string and isinstance(loc_string, LocalizedString):
            # Add StrRef
            if hasattr(loc_string, "stringref"):
                lines.append(f"StrRef={loc_string.stringref}")

            # Add lang# entries
            for lang, gender, text in loc_string:
                substring_id = LocalizedString.substring_id(lang, gender)
                lines.append(f"lang{substring_id}={text}")

    def _get_gff_field_type_name(self, field_type: Any) -> str:
        """Convert GFFFieldType enum to TSLPatcher field type name."""
        from pykotor.resource.formats.gff.gff_data import GFFFieldType  # noqa: PLC0415

        # Mapping based on TSLPatcher reader implementation
        type_mapping = {
            GFFFieldType.UInt8: "Byte",
            GFFFieldType.Int8: "Char",
            GFFFieldType.UInt16: "Word",
            GFFFieldType.Int16: "Short",
            GFFFieldType.UInt32: "DWORD",
            GFFFieldType.Int32: "Int",
            GFFFieldType.Int64: "Int64",
            GFFFieldType.Single: "Float",
            GFFFieldType.Double: "Double",
            GFFFieldType.String: "ExoString",
            GFFFieldType.ResRef: "ResRef",
            GFFFieldType.LocalizedString: "ExoLocString",
            GFFFieldType.Vector3: "Position",
            GFFFieldType.Vector4: "Orientation",
            GFFFieldType.Struct: "Struct",
            GFFFieldType.List: "List",
        }
        return type_mapping.get(field_type, str(field_type.value))

    def _serialize_field_value(self, field_value: Any) -> str:
        """Serialize a FieldValue to its TSLPatcher string representation."""
        if hasattr(field_value, "stored"):  # FieldValueConstant
            return self._format_gff_value(field_value.stored)
        if hasattr(field_value, "token_id"):  # FieldValue2DAMemory or FieldValueTLKMemory
            if "2DAMemory" in type(field_value).__name__:
                return f"2DAMEMORY{field_value.token_id}"
            if "TLKMemory" in type(field_value).__name__:
                return f"StrRef{field_value.token_id}"
        if hasattr(field_value, "value"):  # Generic value method
            return self._format_gff_value(field_value.value(None, None))  # type: ignore[arg-type]
        return self._format_gff_value(field_value)

    def _format_gff_value(  # noqa: PLR0911
        self,
        value: Any,
    ) -> str:
        """Format a GFF field value for INI output with exact TSLPatcher format."""
        if isinstance(value, (Vector3, Vector4)):
            # TSLPatcher expects comma-separated values with specific precision
            if isinstance(value, Vector4):
                return f"{value.x:.6f},{value.y:.6f},{value.z:.6f},{value.w:.6f}"
            return f"{value.x:.6f},{value.y:.6f},{value.z:.6f}"
        if isinstance(value, LocalizedString):
            return str(value.stringref)
        if isinstance(value, ResRef):
            return str(value)
        if isinstance(value, str):
            # Preserve string values as-is (TSLPatcher handles escaping)
            return value
        if isinstance(value, bool):
            return "1" if value else "0"
        if isinstance(value, (int, float)):
            # Format numbers exactly as TSLPatcher expects
            if isinstance(value, float):
                return f"{value:.6f}".rstrip("0").rstrip(".")
            return str(value)
        if value is None:
            return ""
        return str(value)

    def _serialize_tlk_list(
        self,
        modifications: list[ModificationsTLK],
    ) -> list[str]:  # noqa: C901, PLR0912
        """Serialize [TLKList] section."""
        if not modifications:
            return []

        lines: list[str] = []
        mod_tlk: ModificationsTLK = modifications[0]  # Should only be one TLK modification
        assert isinstance(mod_tlk, ModificationsTLK), "mod_tlk should be a ModificationsTLK"

        lines.append("[TLKList]")

        # Determine file types needed
        has_replacements: bool = any(m.is_replacement for m in mod_tlk.modifiers)
        has_appends: bool = any(not m.is_replacement for m in mod_tlk.modifiers)

        # TSLPatcher uses AppendFile# or Replace# (not ReplaceFile#) per example INIs
        if has_appends:
            lines.append("AppendFile0=append.tlk")
        if has_replacements:
            lines.append("Replace0=append.tlk")  # Replace0= is the correct TSLPatcher syntax

        # StrRef mappings
        lines.extend([f"StrRef{tlk_modifier.token_id}={tlk_modifier.mod_index}" for tlk_modifier in mod_tlk.modifiers])

        lines.append("")

        # Generate append.tlk section
        if has_appends:
            lines.append("[append.tlk]")
            lines.extend(
                [
                    f"{tlk_modifier.token_id}={tlk_modifier.mod_index}"
                    for tlk_modifier in mod_tlk.modifiers
                    if not tlk_modifier.is_replacement
                ]
            )
            lines.append("")

        # Generate replace.tlk section
        if has_replacements:
            lines.append("[replace.tlk]")
            lines.extend(
                [
                    f"{tlk_modifier.token_id}={tlk_modifier.mod_index}"
                    for tlk_modifier in mod_tlk.modifiers
                    if tlk_modifier.is_replacement
                ]
            )
            lines.append("")

        return lines

    def _serialize_ssf_list(
        self,
        modifications: list[ModificationsSSF],
    ) -> list[str]:
        """Serialize [SSFList] section."""
        if not modifications:
            return []

        lines: list[str] = []
        lines.append("[SSFList]")

        for idx, mod_ssf in enumerate(modifications):
            prefix = "Replace" if mod_ssf.replace_file else "File"
            lines.append(f"{prefix}{idx}={mod_ssf.sourcefile}")
        lines.append("")

        # Generate each SSF file's sections
        for mod_ssf in modifications:
            lines.extend(self._serialize_ssf_file(mod_ssf))

        return lines

    def _serialize_ssf_file(
        self,
        mod_ssf: ModificationsSSF,
    ) -> list[str]:
        """Serialize a single SSF file's modifications."""
        lines: list[str] = []
        lines.append(f"[{mod_ssf.sourcefile}]")

        # TSLPatcher SSF sound name mappings
        SOUND_NAMES = {
            SSFSound.BATTLE_CRY_1: "Battlecry 1",
            SSFSound.BATTLE_CRY_2: "Battlecry 2",
            SSFSound.BATTLE_CRY_3: "Battlecry 3",
            SSFSound.BATTLE_CRY_4: "Battlecry 4",
            SSFSound.BATTLE_CRY_5: "Battlecry 5",
            SSFSound.BATTLE_CRY_6: "Battlecry 6",
            SSFSound.SELECT_1: "Selected 1",
            SSFSound.SELECT_2: "Selected 2",
            SSFSound.SELECT_3: "Selected 3",
            SSFSound.ATTACK_GRUNT_1: "Attack 1",
            SSFSound.ATTACK_GRUNT_2: "Attack 2",
            SSFSound.ATTACK_GRUNT_3: "Attack 3",
            SSFSound.PAIN_GRUNT_1: "Pain 1",
            SSFSound.PAIN_GRUNT_2: "Pain 2",
            SSFSound.LOW_HEALTH: "Low health",
            SSFSound.DEAD: "Death",
            SSFSound.CRITICAL_HIT: "Critical hit",
            SSFSound.TARGET_IMMUNE: "Target immune",
            SSFSound.LAY_MINE: "Place mine",
            SSFSound.DISARM_MINE: "Disarm mine",
            SSFSound.BEGIN_STEALTH: "Stealth on",
            SSFSound.BEGIN_SEARCH: "Search",
            SSFSound.BEGIN_UNLOCK: "Pick lock start",
            SSFSound.UNLOCK_FAILED: "Pick lock fail",
            SSFSound.UNLOCK_SUCCESS: "Pick lock done",
            SSFSound.SEPARATED_FROM_PARTY: "Leave party",
            SSFSound.REJOINED_PARTY: "Rejoin party",
            SSFSound.POISONED: "Poisoned",
        }

        for ssf_modifier in mod_ssf.modifiers:
            sound_name = SOUND_NAMES.get(ssf_modifier.sound, f"Sound{ssf_modifier.sound.value}")
            value = ssf_modifier.stringref.value(None)  # type: ignore[arg-type]
            lines.append(f"{sound_name}={value}")

        lines.append("")
        return lines

    def _serialize_install_list(
        self,
        install_files: list[tuple[str, list[str]]],
    ) -> list[str]:
        """Serialize [InstallList] section with exact TSLPatcher format.

        Args:
            install_files: List of (folder_path, [filenames]) tuples
        """
        if not install_files:
            return []

        lines: list[str] = []
        lines.append("[InstallList]")

        # List all folder entries (using install_folder# format per TSLPatcher convention)
        for i, (folder, _) in enumerate(install_files):
            dest = folder if folder != "." else "Override"
            lines.append(f"install_folder{i}={dest}")
        lines.append("")

        # Generate folder sections with file lists
        for i, (folder, filenames) in enumerate(install_files):
            dest = folder if folder != "." else "Override"
            section_name = f"install_folder{i}"

            # Add comment for readability
            lines.append(f"; {dest} :")
            lines.append(f"[{section_name}]")

            # List files (all as Replace# since they're from diffs)
            for j, fname in enumerate(sorted(filenames)):
                lines.append(f"Replace{j}={fname}")
            lines.append("")

        return lines
