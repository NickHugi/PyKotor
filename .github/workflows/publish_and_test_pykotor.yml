name: Compile and Test PyKotor

on: [push]

permissions:
  contents: write

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false  # Disable automatic cancellation of other jobs
      matrix:
        os: [windows-2019, ubuntu-20.04, macos-12]
        python-version: ['3.7', '3.8', '3.9', '3.10', '3.11', '3.12', '3.13.0-alpha.4']
        architecture: ['x86', 'x64']
        exclude:
          # unix x86 is definitely not supported.
          - os: ubuntu-20.04
            architecture: x86
          - os: macos-12
            architecture: x86
    outputs:
      matrix-os: ${{ toJson(strategy.matrix.os) }}
      matrix-python-version: ${{ toJson(strategy.matrix.python-version) }}

    steps:
    - uses: actions/checkout@v4
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        architecture: ${{ matrix.architecture }}

    - name: Install python venv from install_python_venv.ps1
      run: |  # create the venv early to work around an issue with the matrix runners' concurrency
        python -m venv .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
        Set-PSDebug -Trace 2
        ./install_python_venv.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh

    - name: Install HoloPatcher dependencies
      run: |
        ./compile/deps_holopatcher.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true
    
    - name: Compile HoloPatcher
      run: |
        ./compile/compile_holopatcher.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Install Holocron Toolset dependencies
      run: |
        ./compile/deps_toolset.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Compile Holocron Toolset
      run: |
        ./compile/compile_toolset.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Install BatchPatcher dependencies
      run: |
        ./compile/deps_batchpatcher.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Compile BatchPatcher
      run: |
        ./compile/compile_batchpatcher.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Compile KotorDiff
      run: |
        ./compile/compile_kotordiff.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Compile GUIDuplicator
      run: |
        ./compile/compile_gui_duplicator.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
      shell: pwsh
      continue-on-error: true

    - name: Upload compiled binaries
      uses: actions/upload-artifact@v4
      if: always()  # This ensures the step runs regardless of previous step's success or failure
      with:
        name: publish_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
        path: ./dist/**

    - name: Install Meson
      if: matrix.python-version == '3.13.0-alpha.4' && (runner.os == 'Linux' || runner.os == 'macOS')
      run: |
        ./install_python_venv.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
        python -m pip install numpy --only-binary :all: --upgrade
        python -m pip install meson --upgrade --prefer-binary

    - name: Install development packages
      run: |
        ./install_python_venv.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
        if ($env:python_version -ne "3.13.0-alpha.4" -or $env:RUNNER_OS -eq "Windows") {
          pip install -r requirements-dev.txt --prefer-binary
        }
        else {
          pip install -r requirements-dev-py313.txt --prefer-binary
        }
      shell: pwsh

    - name: Run all unittests/pytests
      run: |
        ./install_python_venv.ps1 -noprompt -venv_name .venv_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
        python -m pytest tests -v -ra -o log_cli=true --capture=no --junitxml=pytest_report.xml --html=pytest_report.html --self-contained-html --tb=no --continue-on-collection-errors
      shell: pwsh
      continue-on-error: true

    - name: Upload Pytest Reports
      uses: actions/upload-artifact@v4
      if: always()  # Ensures this step runs even if the previous step fails
      with:
        name: pytest-reports_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
        path: |
          pytest_report.html
          pytest_report.xml

  update-readme:
    needs: build  # do not start this job until all 'build' jobs complete
    # always run regardless of whether any builds errored or not.
    if: always()
    runs-on: ubuntu-latest  # Or any other suitable runner
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: pytest-reports

      - name: Extract and update README with custom test status badges
        shell: pwsh
        run: |
          Set-PSDebug -Trace 2

          # Git configuration and commit
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"

          # Determine the branch that triggered the workflow
          $branchName = "${{ github.ref_name }}"

          # Generate a unique name for the temporary branch to avoid conflicts
          $uniqueTempBranchName = "temp-branch-${{ github.run_id }}"

          # Fetch the latest history without altering the working directory
          git fetch

          # Checkout to a unique temporary branch to prepare the new commit
          git checkout -b $uniqueTempBranchName

          $OS_NAMES = @("windows-2019", "ubuntu-20.04", "macos-12")
          $PYTHON_VERSIONS = @('3.7', '3.8', '3.9', '3.10', '3.11', '3.12', '3.13.0-alpha.4')
          $ARCHITECTURES = @('x86', 'x64')
          
          # Ensure the extracted-reports directory is created
          $extractedReportsPath = "extracted-reports"
          New-Item -ItemType Directory -Force -Path $extractedReportsPath

          # Extract all downloaded artifacts
          Get-ChildItem pytest-reports -Filter *.zip | ForEach-Object {
            Expand-Archive -Path $_.FullName -DestinationPath $extractedReportsPath -Force
          }
          
          # Initialize a hashtable to store test results
          $testResults = @{}

          # Process each extracted report
          Get-ChildItem $extractedReportsPath -Recurse -Filter pytest_report.xml | ForEach-Object {
            [xml]$TestResultsXml = Get-Content $_.FullName
            $totalTests = [int]$TestResultsXml.testsuite.tests
            $failedTests = [int]$TestResultsXml.testsuite.failures
            $errors = [int]$TestResultsXml.testsuite.errors
            # Calculate passed tests by subtracting failures and errors from total
            $passedTests = $totalTests - $failedTests - $errors

            # Assuming the use of file names or directory names to distinguish between test results
            # Here we need a consistent approach to generate a key for each test result set
            # This example assumes you're using directory names that reflect the matrix configuration
            $key = $_.Directory.Name.Replace('-', '_')

            # Store results in hashtable with the calculated number of passed and failed tests
            $testResults[$key] = @{
              Passed = $passedTests
              Failed = $failedTests + $errors # Considering errors as failures for badge display
              Total  = $totalTests
            }
          }

          # Update README with test results
          $ReadmePath = "./README.md"
          $ReadmeContent = Get-Content $ReadmePath -Raw
          foreach ($OS in $OS_NAMES) {
            foreach ($PYTHON_VERSION in $PYTHON_VERSIONS) {
              foreach ($ARCH in $ARCHITECTURES) {
                $key = "$OS_$PYTHON_VERSION_$ARCH"
                $passedTests = $testResults[$key]['Passed']
                $failedTests = $testResults[$key]['Failed']
          
                $BadgeURLPassed = "https://img.shields.io/badge/$($OS)_$($PYTHON_VERSION)_$($ARCH)_Passing-$passedTests-brightgreen"
                $BadgeURLFailed = "https://img.shields.io/badge/$($OS)_$($PYTHON_VERSION)_$($ARCH)_Failing-$failedTests-red"
          
                $BadgeNamePassed = "$OS-$PYTHON_VERSION-$ARCH"
                $BadgeNameFailed = "$OS-$PYTHON_VERSION-$ARCH"
          
                # Badge Markdown
                $BadgeMarkdown = "![$BadgeNamePassed]($BadgeURLPassed) ![$BadgeNameFailed]($BadgeURLFailed)"
          
                # Regex to find existing badges for the same OS and Python version
                $BadgeRegex = "!\[$BadgeNamePassed\].+?!\[$BadgeNameFailed\].+?"
          
                if ($ReadmeContent -match $BadgeRegex) {
                  $ReadmeContent = $Readreadmecontent -replace $BadgeRegex, $BadgeMarkdown
                } else {
                  # Prepend the new badges to the top of the README
                  $ReadmeContent = $BadgeMarkdown + "`n`n" + $ReadmeContent
                }
              }
            }
          }

          # Write the updated README content to the file
          Set-Content -Path $ReadmePath -Value $ReadmeContent

          # Commit the changes in the temporary branch
          git commit -am "Update README with custom test status badges" || Write-Host "No changes to commit."

          # Switch back to the original branch
          git checkout $branchName

          # Merge the temporary branch without a fast-forward merge. This ensures
          # a merge commit is created, which incorporates both your changes and any
          # new changes from the remote that were fetched earlier.
          git merge --no-ff $uniqueTempBranchName

          # Delete the temporary branch
          git branch -d $uniqueTempBranchName

          # Push the changes back to the remote repository
          git push origin $branchName
